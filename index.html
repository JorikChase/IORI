<script type="module">
    import * as THREE from "three";
    import { RGBELoader } from "three/addons/loaders/RGBELoader.js";
    import { GUI } from "three/addons/libs/lil-gui.module.min.js";
    import { EffectComposer } from "three/addons/postprocessing/EffectComposer.js";
    import { RenderPass } from "three/addons/postprocessing/RenderPass.js";
    import { ShaderPass } from "three/addons/postprocessing/ShaderPass.js";
    import { FilmPass } from "three/addons/postprocessing/FilmPass.js";
    import { RGBShiftShader } from "three/addons/shaders/RGBShiftShader.js";
    import { MarchingCubes } from "three/addons/objects/MarchingCubes.js";

    let camera, scene, renderer, composer;
    let material, material2;
    let cubeCamera, cubeRenderTarget;
    let effect;

    let mouseX = 0,
        mouseY = 0;
    let windowHalfX = window.innerWidth / 2;
    let windowHalfY = window.innerHeight / 2;

    // Marching cubes parameters
    const numMetaballs = 8;
    const resolution = 48;
    const isolation = 80;
    const subtract = 12;
    const strength = 1.2;

    // Object positions storage
    let objectPositions = new Array(numMetaballs).fill().map(() => ({
        position: new THREE.Vector3(),
        rotation: new THREE.Euler(),
    }));

    init();

    function init() {
        renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setPixelRatio(window.devicePixelRatio);
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setAnimationLoop(animation);
        renderer.outputEncoding = THREE.sRGBEncoding;
        renderer.toneMapping = THREE.ACESFilmicToneMapping;
        renderer.toneMappingExposure = 1.3;
        document.body.appendChild(renderer.domElement);

        document.addEventListener("mousemove", onDocumentMouseMove);
        window.addEventListener("resize", onWindowResized);

        camera = new THREE.PerspectiveCamera(
            90,
            window.innerWidth / window.innerHeight,
            1,
            1000,
        );
        camera.position.z = 70;

        scene = new THREE.Scene();
        scene.rotation.y = 0.5;

        // HDRI
        new RGBELoader()
            .setPath("/IORI/assets/")
            .load("3dieMainBckg.hdr", function (texture) {
                texture.mapping = THREE.EquirectangularReflectionMapping;
                scene.background = texture;
                scene.environment = texture;
            });

        // Cube render target for reflective material
        cubeRenderTarget = new THREE.WebGLCubeRenderTarget(256);
        cubeRenderTarget.texture.type = THREE.HalfFloatType;
        cubeCamera = new THREE.CubeCamera(1, 1000, cubeRenderTarget);

        // Materials
        material = new THREE.MeshStandardMaterial({
            envMap: cubeRenderTarget.texture,
            roughness: 0.05,
            metalness: 1,
        });

        material2 = new THREE.MeshStandardMaterial({
            roughness: 0.05,
            metalness: 0,
        });

        // Initialize marching cubes
        effect = new MarchingCubes(resolution, material2, true, true);
        effect.position.set(0, 0, 0);
        effect.scale.set(100, 100, 100);
        effect.enableUvs = false;
        effect.enableColors = false;
        effect.isolation = isolation;
        scene.add(effect);

        // Post-processing
        composer = new EffectComposer(renderer);
        composer.addPass(new RenderPass(scene, camera));

        const effect2 = new ShaderPass(RGBShiftShader);
        effect2.uniforms["amount"].value = 0.001;
        composer.addPass(effect2);
    }

    function updateMetaballs(time) {
        effect.reset();

        // Update positions using the same motion patterns from the original code
        // Each position represents one of your original objects

        // Cube position
        objectPositions[0].position.set(
            Math.cos(time) * 0.3,
            Math.sin(time) * 0.3,
            Math.sin(time) * 0.3,
        );

        // Torus position
        objectPositions[1].position.set(
            Math.cos(time + 30) * 0.3,
            Math.sin(time + 30) * 0.3,
            Math.sin(time + 30) * 0.3,
        );

        // Tetrahedron position
        objectPositions[2].position.set(
            Math.cos(time + 60) * 0.3,
            Math.sin(time + 60) * 0.3,
            Math.sin(time + 60) * 0.3,
        );

        // Dodecahedron position
        objectPositions[3].position.set(
            Math.cos(time + 90) * 0.3,
            Math.sin(time + 90) * 0.3,
            Math.sin(time + 90) * 0.3,
        );

        // Donut position
        objectPositions[4].position.set(
            Math.sin(time + 15) * 0.3,
            Math.cos(time + 15) * 0.3,
            Math.sin(time + 15) * 0.3,
        );

        // Octahedron position
        objectPositions[5].position.set(
            Math.cos(time + 45) * 0.3,
            Math.cos(time + 45) * 0.3,
            Math.sin(time + 45) * 0.3,
        );

        // Pentahedron position
        objectPositions[6].position.set(
            Math.sin(time + 75) * 0.3,
            Math.cos(time + 75) * 0.3,
            Math.sin(time + 75) * 0.3,
        );

        // Sextahedron position
        objectPositions[7].position.set(
            Math.cos(time + 105) * 0.3,
            Math.cos(time + 105) * 0.3,
            Math.sin(time + 105) * 0.3,
        );

        // Add metaballs at each object position
        objectPositions.forEach((obj, i) => {
            effect.addBall(
                obj.position.x + 0.5,
                obj.position.y + 0.5,
                obj.position.z + 0.5,
                strength,
                subtract,
            );
        });

        effect.update();
    }

    function onWindowResized() {
        windowHalfX = window.innerWidth / 2;
        windowHalfY = window.innerHeight / 2;

        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();

        renderer.setSize(window.innerWidth, window.innerHeight);
        composer.setSize(window.innerWidth, window.innerHeight);
    }

    function onDocumentMouseMove(event) {
        mouseX = (event.clientX - windowHalfX) / 2;
        mouseY = (event.clientY - windowHalfY) / 2;
    }

    function animation(msTime) {
        const time = msTime / 1000;

        // Update metaballs
        updateMetaballs(time);

        // Camera movement
        camera.position.x += (mouseX / 5 - camera.position.x) * 0.01;
        camera.position.y += (-mouseY / 5 - camera.position.y) * 0.02;
        camera.lookAt(scene.position);

        // Update cubemap for reflective material
        cubeCamera.update(renderer, scene);

        renderer.render(scene, camera);
        composer.render();
    }
</script>
